<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>otp_emoji API documentation</title>
<meta name="description" content="Used to generate ğŸ™Š one-time pads ğŸ¤ exclusively in emojis â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>otp_emoji</code></h1>
</header>
<section id="section-intro">
<p>Used to generate ğŸ™Š one-time pads ğŸ¤ exclusively in emojis.</p>
<p>Also has functions for ğŸ”’'ing and ğŸ”“'ing text with the one time pads. The
module exposes both an API and entrypoint. API documentation begins after the
entrypoint usage information.</p>
<h2 id="script-usage">ğŸ–¥ï¸Script Usage</h2>
<p>The usage POSIX string for the otp_emoji script:</p>
<pre><code>
Usage
-----
otp_emoji [-h] [-v]
otp_emoji encrypt &lt;text&gt; [-s] [-o OUTPUT_PATH] [-p PAD_PATH]
otp_emoji decrypt &lt;ciphertext&gt; &lt;pad&gt; [-s] [-o OUTPUT_PATH]
Options:
-h, --help            show this help message and exit
-v, --version         show program's version number and exit
-o OUTPUT_PATH, --output OUTPUT_PATH
                      custom directory of where to write 
                      pad/plaintext/ciphertext output
-p PAD_PATH, --pad PAD_PATH
                      allows you to specify a pre-created one time pad
-s, --stream          print result to output stream (stdout)
</code></pre>
<p>So for example you could run <code>otp_emoji encrypt secret_text.txt</code> which will create
a ciphertext and pad of the contents of secret_text.txt and output them to the current
directory as <code>pad.txt</code> and <code>ciphertext.txt</code> respectively. You could then run
<code>otp_emoji decrypt ciphertext.txt pad.txt</code> which would decrypt the message and send the
output to the current directory as <code>plaintext.txt</code>.</p>
<h2 id="variables">ğŸ“¦Variables</h2>
<p>chipher_chars : (list)
The list of emojis useable for creating one time pads</p>
<p>usage : (str)
The POSIX usage string that drives docopt for the <code>otp_emoji</code> script</p>
<h2 id="notes">ğŸ“Notes</h2>
<ul>
<li>
<p>ğŸš« DON'T USE THIS IN PRODUCTION ğŸš« I created this project to help better
understand my security course in ğŸ«.</p>
</li>
<li>
<p>Note that because of the mapping necessary to make the project more secure in case someone
does actually use this only ASCII characters can be used. </p>
</li>
<li>
<p>No I will not put this on PyPi, again I put minimal effort into this and it's
better for it to remain a dissapointment to me than the python community as a whole.</p>
</li>
<li>
<p>When opening a text file with the api make sure to pass the encoding parameter to open()
as 'UTF-8' otherwise there will be an error when the charmaps are read. i.e. </p>
</li>
</ul>
<pre><code>with open('pad.txt', encoding='utf-8') as pad_file:
    pad = pad_file.read()
</code></pre>
<h2 id="references">ğŸ‘©â€ğŸ«References</h2>
<p>One Time Pad explanations:</p>
<pre><code>- &lt;https://searchsecurity.techtarget.com/definition/one-time-pad&gt;

- &lt;http://users.telenet.be/d.rijmenants/en/onetimepad.htm&gt;

- &lt;https://www.cryptomuseum.com/crypto/otp/index.htm&gt;

- &lt;https://medium.com/blockgeeks-blog/cryptography-for-dummies-part-4-the-one-time-pad-7711438c9b8a&gt;
</code></pre>
<p>ASCII chart for supported characters:
- <a href="https://www.commfront.com/pages/ascii-chart">https://www.commfront.com/pages/ascii-chart</a></p>
<h2 id="examples">ğŸ¤·Examples</h2>
<p>Encrypting 'Do not go gentle into that good night' by Dylan Thomas</p>
<pre><code>from otp_emoji import encrypt, decrypt

text = '''Do not go gentle into that good night,
Old age should burn and rave at close of day;
Rage, rage against the dying of the light.

Though wise men at their end know dark is right,
Because their words had forked no lightning they
Do not go gentle into that good night.

Good men, the last wave by, crying how bright
Their frail deeds might have danced in a green bay,
Rage, rage against the dying of the light.

Wild men who caught and sang the sun in flight,
And learn, too late, they grieved it on its way,
Do not go gentle into that good night.

Grave men, near death, who see with blinding sight
Blind eyes could blaze like meteors and be gay,
Rage, rage against the dying of the light.

And you, my father, there on the sad height,
Curse, bless, me now with your fierce tears, I pray.
Do not go gentle into that good night.
Rage, rage against the dying of the light.'''

ciphertext, pad = encrypt(text, pad_path='./pad.txt', ciphertext_path='./ciphertext.txt')

decrypt(ciphertext, pad, text_path='./decrypted_text.txt')
</code></pre>
<h2 id="todo">TODO</h2>
<ul>
<li>Get emoji map up to 255</li>
<li>Change generate OTP to use emoji map and secrets hex generation</li>
<li>Write ciphertext as emoji's</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Used to generate ğŸ™Š one-time pads ğŸ¤ exclusively in emojis.

Also has functions for ğŸ”’&#39;ing and ğŸ”“&#39;ing text with the one time pads. The
module exposes both an API and entrypoint. API documentation begins after the
entrypoint usage information.


ğŸ–¥ï¸Script Usage
--------------
The usage POSIX string for the otp_emoji script:
```
Usage:
    otp_emoji [-h] [-v]
    otp_emoji encrypt &lt;text&gt; [-s] [-o OUTPUT_PATH] [-p PAD_PATH]
    otp_emoji decrypt &lt;ciphertext&gt; &lt;pad&gt; [-s] [-o OUTPUT_PATH]


Options:
-h, --help            show this help message and exit
-v, --version         show program&#39;s version number and exit
-o OUTPUT_PATH, --output OUTPUT_PATH
                      custom directory of where to write 
                      pad/plaintext/ciphertext output
-p PAD_PATH, --pad PAD_PATH
                      allows you to specify a pre-created one time pad
-s, --stream          print result to output stream (stdout)
```

So for example you could run ```otp_emoji encrypt secret_text.txt``` which will create
a ciphertext and pad of the contents of secret_text.txt and output them to the current
directory as ```pad.txt``` and ```ciphertext.txt``` respectively. You could then run
```otp_emoji decrypt ciphertext.txt pad.txt``` which would decrypt the message and send the
output to the current directory as ```plaintext.txt```.

ğŸ“¦Variables
------------
chipher_chars : (list)
    The list of emojis useable for creating one time pads

usage : (str)
    The POSIX usage string that drives docopt for the ``otp_emoji`` script

ğŸ“Notes
--------
- ğŸš« DON&#39;T USE THIS IN PRODUCTION ğŸš« I created this project to help better
    understand my security course in ğŸ«.

- Note that because of the mapping necessary to make the project more secure in case someone
    does actually use this only ASCII characters can be used. 

- No I will not put this on PyPi, again I put minimal effort into this and it&#39;s
    better for it to remain a dissapointment to me than the python community as a whole.

- When opening a text file with the api make sure to pass the encoding parameter to open()
    as &#39;UTF-8&#39; otherwise there will be an error when the charmaps are read. i.e. 
```
with open(&#39;pad.txt&#39;, encoding=&#39;utf-8&#39;) as pad_file:
    pad = pad_file.read()
```

ğŸ‘©â€ğŸ«References
-------------
One Time Pad explanations:

    - https://searchsecurity.techtarget.com/definition/one-time-pad

    - http://users.telenet.be/d.rijmenants/en/onetimepad.htm

    - https://www.cryptomuseum.com/crypto/otp/index.htm

    - https://medium.com/blockgeeks-blog/cryptography-for-dummies-part-4-the-one-time-pad-7711438c9b8a

ASCII chart for supported characters:
    - https://www.commfront.com/pages/ascii-chart

ğŸ¤·Examples
-----------
Encrypting &#39;Do not go gentle into that good night&#39; by Dylan Thomas

```
from otp_emoji import encrypt, decrypt

text = &#39;&#39;&#39;Do not go gentle into that good night,
Old age should burn and rave at close of day;
Rage, rage against the dying of the light.

Though wise men at their end know dark is right,
Because their words had forked no lightning they
Do not go gentle into that good night.

Good men, the last wave by, crying how bright
Their frail deeds might have danced in a green bay,
Rage, rage against the dying of the light.

Wild men who caught and sang the sun in flight,
And learn, too late, they grieved it on its way,
Do not go gentle into that good night.

Grave men, near death, who see with blinding sight
Blind eyes could blaze like meteors and be gay,
Rage, rage against the dying of the light.

And you, my father, there on the sad height,
Curse, bless, me now with your fierce tears, I pray.
Do not go gentle into that good night.
Rage, rage against the dying of the light.&#39;&#39;&#39;

ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)

decrypt(ciphertext, pad, text_path=&#39;./decrypted_text.txt&#39;)
```

TODO
----
* Get emoji map up to 255
* Change generate OTP to use emoji map and secrets hex generation
* Write ciphertext as emoji&#39;s
&#34;&#34;&#34;

# Standard lib dependencies
import os                       # Used to validate filepaths
import sys                      # Used to fix arglengths of 0 for CLI
import logging                  # Used to log (obviously)
from copy import deepcopy
from typing import Generator    # Used to typehint generator returns
from secrets import token_hex   # Used to produce reliably random hex values


# External Dependencies
from docopt import docopt   # Used to handle argument parsing from the entrypoint

usage = &#34;&#34;&#34;Used to generate one-time pads ğŸ¤, by default in emojis.

Usage:
    otp_emoji [-h] [-v]
    otp_emoji encrypt &lt;text&gt; [-s] [-o OUTPUT_PATH] [-p PAD_PATH] 
    otp_emoji decrypt &lt;ciphertext&gt; &lt;pad&gt; [-s] [-o OUTPUT_PATH] 


Options:
-h, --help            show this help message and exit
-v, --version         show program&#39;s version number and exit
-o OUTPUT_PATH, --output OUTPUT_PATH
                      a directory of where to write pad/plaintext/ciphertext
                       output
-p PAD_PATH, --pad PAD_PATH
                      allows you to specify a pre-created one time pad
-s, --stream          print result to output stream (stdout)
&#34;&#34;&#34;

cipher_chars = [
    &#34;ğŸ¤—&#34;, &#34;ğŸ™„&#34;, &#34;ğŸ¤®&#34;, &#34;ğŸ¤§&#34;, &#34;ğŸ¥µ&#34;, &#34;ğŸ™&#34;, &#34;ğŸ‘…&#34;, &#34;ğŸ’&#34;, &#34;ğŸ†&#34;, &#34;ğŸ‡&#34;, &#34;ğŸŒ&#34;, &#34;ğŸ‹&#34;, &#34;ğŸŒµ&#34;, &#34;ğŸ‘&#34;, &#34;ğŸ‘€&#34;,
    &#34;ğŸ‘¨â€ğŸ’»&#34;, &#34;ğŸ‘¨â€ğŸ¤&#34;, &#34;ğŸ§›&#34;, &#34;ğŸ§œâ€â™€ï¸&#34;, &#34;ğŸ§â€â™‚ï¸&#34;, &#34;ğŸ§&#34;, &#34;ğŸ‘¨â€ğŸ¦¼&#34;, &#34;ğŸ§—&#34;, &#34;â›·&#34;, &#34;ğŸ¶&#34;, &#34;ğŸ¦Š&#34;, &#34;ğŸ¦„&#34;, &#34;ğŸŠ&#34;, &#34;ğŸ¢&#34;, &#34;ğŸ¦œ&#34;, &#34;ğŸ¦‰&#34;,
    &#34;ğŸ™&#34;, &#34;ğŸ³&#34;, &#34;ğŸ‰&#34;, &#34;ğŸ¦–&#34;, &#34;ğŸ¦‚&#34;, &#34;ğŸ¥&#34;, &#34;ğŸ¥¨&#34;, &#34;ğŸ¥¯&#34;, &#34;ğŸ¥&#34;, &#34;ğŸ”&#34;, &#34;ğŸ•&#34;, &#34;ğŸ§ˆ&#34;, &#34;ğŸœ&#34;, &#34;ğŸ¦€&#34;, &#34;ğŸ¦&#34;, &#34;ğŸ¦‘&#34;,
    &#34;ğŸº&#34;, &#34;ğŸš„&#34;, &#34;ğŸš”&#34;, &#34;ğŸ¦¼&#34;, &#34;ğŸš€&#34;, &#34;ğŸ›¸&#34;, &#34;ğŸŒš&#34;, &#34;â„&#34;, &#34;ğŸŒŠ&#34;, &#34;ğŸ¥Œ&#34;, &#34;â™Ÿ&#34;, &#34;ğŸ¦º&#34;, &#34;ğŸ©&#34;, &#34;ğŸ·&#34;, &#34;ğŸ’»&#34;, &#34;ğŸ’¾&#34;,
    &#34;ğŸ¤&#34;, &#34;ğŸ¤˜&#34;, &#34;ğŸ¤&#34;, &#34;ğŸ¤™&#34;, &#34;ğŸ–•&#34;, &#34;ğŸ‘Š&#34;, &#34;ğŸ¤›&#34;, &#34;ğŸ™Œ&#34;, &#34;ğŸ‘&#34;, &#34;ğŸ¤³&#34;, &#34;ğŸ’ª&#34;, &#34;ğŸ‘‚&#34;, &#34;ğŸ‘&#34;, &#34;ğŸ‘¨â€ğŸ¦°&#34;, &#34;ğŸ‘¨â€ğŸ¦±&#34;, &#34;ğŸ§”&#34;, &#34;ğŸ‘©â€ğŸ¦³&#34;,
    &#34;ğŸ‘©&#34;, &#34;ğŸ‘©â€ğŸ¦²&#34;, &#34;ğŸ‘´&#34;, &#34;ğŸ™…&#34;, &#34;ğŸ™†&#34;, &#34;ğŸ’â€â™‚ï¸&#34;, &#34;ğŸ™‹â€â™€ï¸&#34;, &#34;ğŸ§â€â™‚ï¸&#34;, &#34;ğŸ™‡&#34;, &#34;ğŸ¤¦&#34;, &#34;ğŸ¤¦â€â™‚ï¸&#34;, &#34;ğŸ¤¦â€â™€ï¸&#34;, &#34;ğŸ¤·&#34;, &#34;ğŸ¤·â€â™‚ï¸&#34;, &#34;ğŸ¤·â€â™€ï¸&#34;, &#34;ğŸ‘¨â€ğŸ“&#34;, &#34;ğŸ‘¨â€ğŸ«&#34;,
    &#34;ğŸ‘¨â€ğŸŒ¾&#34;, &#34;ğŸ‘¨â€ğŸ”§&#34;, &#34;ğŸ‘©â€ğŸ­&#34;, &#34;ğŸ‘©â€ğŸ’¼&#34;, &#34;ğŸ‘¨â€ğŸ”¬&#34;, &#34;ğŸ‘©â€ğŸ’»&#34;, &#34;ğŸ‘¨â€ğŸ¨&#34;, &#34;ğŸ‘©â€âœˆï¸&#34;, &#34;ğŸ‘®&#34;, &#34;ğŸ•µ&#34;, &#34;ğŸ’‚&#34;, &#34;ğŸ‘·&#34;, &#34;ğŸ…&#34;, &#34;ğŸ¦¸&#34;, &#34;ğŸ§™&#34;, &#34;ğŸ§š&#34;, &#34;ğŸ’‡&#34;, &#34;ğŸ‘¨â€ğŸ¦¯&#34;,
    &#34;ğŸ‘¯&#34;, &#34;ğŸ¤º&#34;, &#34;ğŸ‡&#34;, &#34;ğŸŒ&#34;, &#34;â›¹&#34;, &#34;ğŸ‹&#34;, &#34;ğŸš´&#34;, &#34;ğŸ¤¸&#34;, &#34;ğŸ¤½&#34;, &#34;ğŸ¤¼&#34;, &#34;ğŸ¤¹&#34;, &#34;ğŸ§˜&#34;, &#34;ğŸ›Œ&#34;, &#34;ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦&#34;, &#34;ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§&#34;, &#34;ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦&#34;, &#34;ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦&#34;, &#34;ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§&#34;,
    &#34;ğŸ¤&#34;, &#34;ğŸ–¤&#34;, &#34;ğŸ’œ&#34;, &#34;ğŸ’™&#34;, &#34;ğŸ’š&#34;, &#34;ğŸ’›&#34;, &#34;ğŸ§¡&#34;, &#34;ğŸ’¯&#34;, &#34;ğŸ’¥&#34;, &#34;ğŸ’¦&#34;, &#34;ğŸ’£&#34;, &#34;ğŸ’¨&#34;, &#34;ğŸ’¤&#34;, &#34;ğŸ‘‹&#34;, &#34;ğŸ–&#34;, &#34;ğŸ––&#34;, &#34;ğŸ„&#34;, &#34;ğŸš£&#34;,
    &#34;ğŸŠ&#34;, &#34;ğŸ¿&#34;, &#34;ğŸ¹&#34;, &#34;ğŸ€&#34;, &#34;ğŸ¦‡&#34;, &#34;ğŸ¦¥&#34;, &#34;ğŸ¦¦&#34;, &#34;ğŸ¦¨&#34;, &#34;ğŸ¦˜&#34;, &#34;ğŸ¦ƒ&#34;, &#34;ğŸ”&#34;, &#34;ğŸ¥&#34;, &#34;ğŸ§&#34;, &#34;ğŸ•Š&#34;, &#34;ğŸ¦…&#34;, &#34;ğŸ¦†&#34;, &#34;ğŸ¦¢&#34;, &#34;ğŸŒ&#34;, 
    &#34;ğŸ¦‹&#34;, &#34;ğŸ›&#34;, &#34;ğŸ&#34;, &#34;ğŸœ&#34;, &#34;ğŸ¦—&#34;, &#34;ğŸ&#34;, &#34;ğŸ•·&#34;, &#34;ğŸ’®&#34;, &#34;ğŸµ&#34;, &#34;ğŸŒ·&#34;, &#34;ğŸŒ±&#34;, &#34;ğŸŒ¿&#34;, &#34;ğŸ‚&#34;, &#34;ğŸ¥‘&#34;, &#34;ğŸŒ¶&#34;, &#34;ğŸ¥™&#34;, &#34;ğŸ³&#34;, &#34;ğŸ¥˜&#34;, &#34;ğŸ¿&#34;,
    &#34;ğŸº&#34;, &#34;ğŸ»&#34;, &#34;ğŸ¥ƒ&#34;, &#34;ğŸ½&#34;, &#34;ğŸ”&#34;, &#34;ğŸ›&#34;, &#34;ğŸ—&#34;, &#34;ğŸ°&#34;, &#34;ğŸ—½&#34;, &#34;ğŸ—¼&#34;, &#34;â›©&#34;, &#34;ğŸ•‹&#34;, &#34;ğŸ›•&#34;, &#34;â›²&#34;, &#34;ğŸŒ&#34;, &#34;â™¨&#34;, &#34;ğŸŒ‰&#34;, &#34;ğŸ¡&#34;, &#34;ğŸ›¤&#34;, &#34;â›½&#34;,
    &#34;â›µ&#34;, &#34;ğŸš¤&#34;, &#34;âœˆ&#34;, &#34;ğŸš&#34;, &#34;ğŸ›&#34;, &#34;ğŸ§³&#34;, &#34;ğŸŒ‘&#34;, &#34;ğŸŒ’&#34;, &#34;ğŸŒ“&#34;, &#34;ğŸŒ”&#34;, &#34;ğŸŒ•&#34;, &#34;ğŸŒ›&#34;, &#34;ğŸŒœ&#34;, &#34;ğŸª&#34;, &#34;â­&#34;, &#34;ğŸŒŸ&#34;, &#34;ğŸŒŒ&#34;, &#34;ğŸŒª&#34;, &#34;ğŸŒ€&#34;, &#34;â›±&#34;,
    &#34;âš¡&#34;, &#34;â˜ƒ&#34;, &#34;ğŸ”¥&#34;, &#34;ğŸ’§&#34;, &#34;ğŸŒŠ&#34;, &#34;ğŸ&#34;, &#34;ğŸ&#34;, &#34;ğŸ§§&#34;, &#34;ğŸ¥Š&#34;, &#34;ğŸ¥…&#34;, &#34;ğŸ£&#34;, &#34;ğŸ¤¿&#34;, &#34;ğŸ¿&#34;, &#34;ğŸ¥Œ&#34;, &#34;ğŸ±&#34;, &#34;ğŸ®&#34;, &#34;ğŸ°&#34;, &#34;ğŸ²&#34;, &#34;â™ &#34;, &#34;â™Ÿ&#34;, 
    &#34;ğŸ´&#34;, &#34;ğŸ§µ&#34;, &#34;ğŸ¥¼&#34;, &#34;ğŸ‘”&#34;, &#34;ğŸ§¥&#34;, &#34;ğŸ¥¾&#34;, &#34;ğŸ–¨&#34;, &#34;ğŸ†˜&#34;

]

emoji_map = {
        &#34;ğŸ¤—&#34; : 0,&#34;ğŸ™„&#34; : 1,&#34;ğŸ¤®&#34; : 2,&#34;ğŸ¤§&#34; : 3,&#34;ğŸ¥µ&#34; : 4,&#34;ğŸ™&#34; : 5,&#34;ğŸ‘…&#34; : 6,&#34;ğŸ’&#34; : 7,&#34;ğŸ†&#34; : 8,&#34;ğŸ‡&#34; : 9,&#34;ğŸŒ&#34; : 10,
        &#34;ğŸ‹&#34; : 11,&#34;ğŸŒµ&#34; : 12,&#34;ğŸ‘&#34; : 13,&#34;ğŸ‘€&#34; : 14,&#34;ğŸ‘¨â€ğŸ’»&#34; : 15,&#34;ğŸ‘¨â€ğŸ¤&#34; : 16,&#34;ğŸ§›&#34; : 17,&#34;ğŸ§œâ€â™€ï¸&#34; : 18,&#34;ğŸ§â€â™‚ï¸&#34; : 19,&#34;ğŸ§&#34; : 20,
        &#34;ğŸ‘¨â€ğŸ¦¼&#34; : 21,&#34;ğŸ§—&#34; : 22,&#34;â›·&#34; : 23,&#34;ğŸ¶&#34; : 24,&#34;ğŸ¦Š&#34; : 25,&#34;ğŸ¦„&#34; : 26,&#34;ğŸŠ&#34; : 27,&#34;ğŸ¢&#34; : 28,&#34;ğŸ¦œ&#34; : 29,&#34;ğŸ¦‰&#34; : 30,
        &#34;ğŸ™&#34; : 31,&#34;ğŸ³&#34; : 32,&#34;ğŸ‰&#34; : 33,&#34;ğŸ¦–&#34; : 34,&#34;ğŸ¦‚&#34; : 35,&#34;ğŸ¥&#34; : 36,&#34;ğŸ¥¨&#34; : 37,&#34;ğŸ¥¯&#34; : 38,&#34;ğŸ¥&#34; : 39,&#34;ğŸ”&#34; : 40,
        &#34;ğŸ•&#34; : 41,&#34;ğŸ§ˆ&#34; : 42,&#34;ğŸœ&#34; : 43,&#34;ğŸ¦€&#34; : 44,&#34;ğŸ¦&#34; : 45,&#34;ğŸ¦‘&#34; : 46,&#34;ğŸº&#34; : 47,&#34;ğŸš„&#34; : 48,&#34;ğŸš”&#34; : 49,&#34;ğŸ¦¼&#34; : 50,
        &#34;ğŸš€&#34; : 51,&#34;ğŸ›¸&#34; : 52,&#34;ğŸŒš&#34; : 53,&#34;â„&#34; : 54,&#34;ğŸŒŠ&#34; : 232,&#34;ğŸ¥Œ&#34; : 241,&#34;â™Ÿ&#34; : 247,&#34;ğŸ¦º&#34; : 58,&#34;ğŸ©&#34; : 59,&#34;ğŸ·&#34; : 60,
        &#34;ğŸ’»&#34; : 61,&#34;ğŸ’¾&#34; : 62,&#34;ğŸ¤&#34; : 63,&#34;ğŸ¤˜&#34; : 64,&#34;ğŸ¤&#34; : 65,&#34;ğŸ¤™&#34; : 66,&#34;ğŸ–•&#34; : 67,&#34;ğŸ‘Š&#34; : 68,&#34;ğŸ¤›&#34; : 69,&#34;ğŸ™Œ&#34; : 70,
        &#34;ğŸ‘&#34; : 71,&#34;ğŸ¤³&#34; : 72,&#34;ğŸ’ª&#34; : 73,&#34;ğŸ‘‚&#34; : 74,&#34;ğŸ‘&#34; : 75,&#34;ğŸ‘¨â€ğŸ¦°&#34; : 76,&#34;ğŸ‘¨â€ğŸ¦±&#34; : 77,&#34;ğŸ§”&#34; : 78,&#34;ğŸ‘©â€ğŸ¦³&#34; : 79,&#34;ğŸ‘©&#34; : 80,
        &#34;ğŸ‘©â€ğŸ¦²&#34; : 81,&#34;ğŸ‘´&#34; : 82,&#34;ğŸ™…&#34; : 83,&#34;ğŸ™†&#34; : 84,&#34;ğŸ’â€â™‚ï¸&#34; : 85,&#34;ğŸ™‹â€â™€ï¸&#34; : 86,&#34;ğŸ§â€â™‚ï¸&#34; : 87,&#34;ğŸ™‡&#34; : 88,&#34;ğŸ¤¦&#34; : 89,&#34;ğŸ¤¦â€â™‚ï¸&#34; : 90,
        &#34;ğŸ¤¦â€â™€ï¸&#34; : 91,&#34;ğŸ¤·&#34; : 92,&#34;ğŸ¤·â€â™‚ï¸&#34; : 93,&#34;ğŸ¤·â€â™€ï¸&#34; : 94,&#34;ğŸ‘¨â€ğŸ“&#34; : 95,&#34;ğŸ‘¨â€ğŸ«&#34; : 96,&#34;ğŸ‘¨â€ğŸŒ¾&#34; : 97,&#34;ğŸ‘¨â€ğŸ”§&#34; : 98,&#34;ğŸ‘©â€ğŸ­&#34; : 99,&#34;ğŸ‘©â€ğŸ’¼&#34; : 100,
        &#34;ğŸ‘¨â€ğŸ”¬&#34; : 101,&#34;ğŸ‘©â€ğŸ’»&#34; : 102,&#34;ğŸ‘¨â€ğŸ¨&#34; : 103,&#34;ğŸ‘©â€âœˆï¸&#34; : 104,&#34;ğŸ‘®&#34; : 105,&#34;ğŸ•µ&#34; : 106,&#34;ğŸ’‚&#34; : 107,&#34;ğŸ‘·&#34; : 108,&#34;ğŸ…&#34; : 109,&#34;ğŸ¦¸&#34; : 110,
        &#34;ğŸ§™&#34; : 111,&#34;ğŸ§š&#34; : 112,&#34;ğŸ’‡&#34; : 113,&#34;ğŸ‘¨â€ğŸ¦¯&#34; : 114,&#34;ğŸ‘¯&#34; : 115,&#34;ğŸ¤º&#34; : 116,&#34;ğŸ‡&#34; : 117,&#34;ğŸŒ&#34; : 118,&#34;â›¹&#34; : 119,&#34;ğŸ‹&#34; : 120,
        &#34;ğŸš´&#34; : 121,&#34;ğŸ¤¸&#34; : 122,&#34;ğŸ¤½&#34; : 123,&#34;ğŸ¤¼&#34; : 124,&#34;ğŸ¤¹&#34; : 125,&#34;ğŸ§˜&#34; : 126,&#34;ğŸ›Œ&#34; : 127,&#34;ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦&#34; : 128,&#34;ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§&#34; : 129,&#34;ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦&#34; : 130,
        &#34;ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦&#34; : 131,&#34;ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§&#34; : 132,&#34;ğŸ¤&#34; : 133,&#34;ğŸ–¤&#34; : 134,&#34;ğŸ’œ&#34; : 135,&#34;ğŸ’™&#34; : 136,&#34;ğŸ’š&#34; : 137,&#34;ğŸ’›&#34; : 138,&#34;ğŸ§¡&#34; : 139,&#34;ğŸ’¯&#34; : 140,
        &#34;ğŸ’¥&#34; : 141,&#34;ğŸ’¦&#34; : 142,&#34;ğŸ’£&#34; : 143,&#34;ğŸ’¨&#34; : 144,&#34;ğŸ’¤&#34; : 145,&#34;ğŸ‘‹&#34; : 146,&#34;ğŸ–&#34; : 147,&#34;ğŸ––&#34; : 148,&#34;ğŸ„&#34; : 149,&#34;ğŸš£&#34; : 150,
        &#34;ğŸŠ&#34; : 151,&#34;ğŸ¿&#34; : 152,&#34;ğŸ¹&#34; : 153,&#34;ğŸ€&#34; : 154,&#34;ğŸ¦‡&#34; : 155,&#34;ğŸ¦¥&#34; : 156,&#34;ğŸ¦¦&#34; : 157,&#34;ğŸ¦¨&#34; : 158,&#34;ğŸ¦˜&#34; : 159,&#34;ğŸ¦ƒ&#34; : 160,
        &#34;ğŸ”&#34; : 161,&#34;ğŸ¥&#34; : 162,&#34;ğŸ§&#34; : 163,&#34;ğŸ•Š&#34; : 164,&#34;ğŸ¦…&#34; : 165,&#34;ğŸ¦†&#34; : 166,&#34;ğŸ¦¢&#34; : 167,&#34;ğŸŒ&#34; : 168,&#34;ğŸ¦‹&#34; : 169,&#34;ğŸ›&#34; : 170,
        &#34;ğŸ&#34; : 171,&#34;ğŸœ&#34; : 172,&#34;ğŸ¦—&#34; : 173,&#34;ğŸ&#34; : 174,&#34;ğŸ•·&#34; : 175,&#34;ğŸ’®&#34; : 176,&#34;ğŸµ&#34; : 177,&#34;ğŸŒ·&#34; : 178,&#34;ğŸŒ±&#34; : 179,&#34;ğŸŒ¿&#34; : 180,
        &#34;ğŸ‚&#34; : 181,&#34;ğŸ¥‘&#34; : 182,&#34;ğŸŒ¶&#34; : 183,&#34;ğŸ¥™&#34; : 184,&#34;ğŸ³&#34; : 185,&#34;ğŸ¥˜&#34; : 186,&#34;ğŸ¿&#34; : 187,&#34;ğŸº&#34; : 188,&#34;ğŸ»&#34; : 189,&#34;ğŸ¥ƒ&#34; : 190,
        &#34;ğŸ½&#34; : 191,&#34;ğŸ”&#34; : 192,&#34;ğŸ›&#34; : 193,&#34;ğŸ—&#34; : 194,&#34;ğŸ°&#34; : 195,&#34;ğŸ—½&#34; : 196,&#34;ğŸ—¼&#34; : 197,&#34;â›©&#34; : 198,&#34;ğŸ•‹&#34; : 199,&#34;ğŸ›•&#34; : 200,
        &#34;â›²&#34; : 201,&#34;ğŸŒ&#34; : 202,&#34;â™¨&#34; : 203,&#34;ğŸŒ‰&#34; : 204,&#34;ğŸ¡&#34; : 205,&#34;ğŸ›¤&#34; : 206,&#34;â›½&#34; : 207,&#34;â›µ&#34; : 208,&#34;ğŸš¤&#34; : 209,&#34;âœˆ&#34; : 210,
        &#34;ğŸš&#34; : 211,&#34;ğŸ›&#34; : 212,&#34;ğŸ§³&#34; : 213,&#34;ğŸŒ‘&#34; : 214,&#34;ğŸŒ’&#34; : 215,&#34;ğŸŒ“&#34; : 216,&#34;ğŸŒ”&#34; : 217,&#34;ğŸŒ•&#34; : 218,&#34;ğŸŒ›&#34; : 219,&#34;ğŸŒœ&#34; : 220,
        &#34;ğŸª&#34; : 221,&#34;â­&#34; : 222,&#34;ğŸŒŸ&#34; : 223,&#34;ğŸŒŒ&#34; : 224,&#34;ğŸŒª&#34; : 225,&#34;ğŸŒ€&#34; : 226,&#34;â›±&#34; : 227,&#34;âš¡&#34; : 228,&#34;â˜ƒ&#34; : 229,&#34;ğŸ”¥&#34; : 230,
        &#34;ğŸ’§&#34; : 231,&#34;ğŸ&#34; : 233,&#34;ğŸ&#34; : 234,&#34;ğŸ§§&#34; : 235,&#34;ğŸ¥Š&#34; : 236,&#34;ğŸ¥…&#34; : 237,&#34;ğŸ£&#34; : 238,&#34;ğŸ¤¿&#34; : 239,&#34;ğŸ¿&#34; : 240,&#34;ğŸ±&#34; : 242,
        &#34;ğŸ®&#34; : 243,&#34;ğŸ°&#34; : 244,&#34;ğŸ²&#34; : 245,&#34;â™ &#34; : 246,&#34;ğŸ´&#34; : 248,&#34;ğŸ§µ&#34; : 249,&#34;ğŸ¥¼&#34; : 250,&#34;ğŸ‘”&#34; : 251,&#34;ğŸ§¥&#34; : 252,&#34;ğŸ¥¾&#34; : 253,
        &#34;ğŸ–¨&#34; : 254,&#34;ğŸ†˜&#34; : 255
}


def generate_otp(length:int) -&gt; Generator:
    &#34;&#34;&#34;Generates a one time pad of emojis based on input length.

    Parameters
    ----------
    length:(int)
        The amount of random emoji&#39;s to generate.
        
    Yields
    ------
    str:
        The next character in the one time pad

    Examples
    --------
    Generating a 10 character otp
    ```
    from otp_emoji import generate_otp

    otp = generate_otp(10)

    for character in otp:   # Iterate through resulting generator
        print(character)    # Prints: ğŸ™ğŸ§—ğŸ§›ğŸ‘¨â€ğŸ¤ğŸ©ğŸ¥¯ğŸ§›ğŸ™„ğŸºğŸ§
    ```
    &#34;&#34;&#34;
    for digit in range(length):
        hex_value = int(token_hex(1), 16)
        yield cipher_chars[hex_value] + &#34;|&#34;

def encrypt(input_text:str, pad:bool=False, pad_path:str = False, ciphertext_path:str = False) -&gt; tuple:
    &#34;&#34;&#34;Encrypts ğŸ”’ text using provided pad, or generates one of the same length.

    Parameters
    ----------
    input_text:(str)
        The text you would like to encrypt.

    pad:(bool|str)
        If pad is specified it will be used to encrypt 
        if left False it will be generated for you.

    pad_path:(bool|str)
        If specified then it will be the path the pad is
        written to.

    ciphertext_path:(bool|str)
        If specified then it will be the path the ciphertext
        is written to.
        
    Returns
    ------
    tuple[str,str]:
        The ciphertext, and the onetime pad

    Examples
    --------
    Encrypting a 1984 (George Orwell) quote and saving
    the resulting ciphertext and path to files.
    ```
    from otp_emoji import encrypt

    text = &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;

    # Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
    ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)
    ```
    &#34;&#34;&#34;
    print(&#34;ğŸ”’ Encrypting Text ğŸ”’&#34;)

    logging.debug(f&#34;input_text = {input_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)
    logging.debug(f&#34;pad_path={pad_path}&#34;)
    logging.debug(f&#34;ciphertext_path={ciphertext_path}&#34;)


    ciphertext = &#34;&#34;
    if not pad:
        pad = &#34;&#34;
        for count, character in enumerate(generate_otp(len(input_text))):
            logging.debug(character)
            pad += character
            shifted_value = &#34;&#34;
            character = character[0:-1] # remove | delimiter from pad character

            logging.debug(f&#34;{input_text[count]} ^ {character}({emoji_map[character]})&#34;)
            shifted_value += cipher_chars[(ord(input_text[count]) ^ emoji_map[character])]

            ciphertext += (shifted_value) + &#34;|&#34; # Delimit ciphertext by pipes and append

        logging.debug(f&#34;pad={pad}&#34;)
    
    else: # If custom pad is provided
        pad = deepcopy(pad)
        pad = pad.split(&#34;|&#34;)
        for character in zip(input_text, pad):
            print(f&#34;Character= {character[0]} {character[1]}&#34;)
            shifted_value = &#34;&#34;
            logging.debug(f&#34;{input_text[count]} ^ {character}({emoji_map[character]})&#34;)
            shifted_value += cipher_chars[(ord(input_text[count]) ^ emoji_map[character])]

            ciphertext += (shifted_value) + &#34;|&#34; # Delimit ciphertext by pipes and append

    ciphertext = ciphertext[0:-1]
    if pad_path:
        with open(pad_path, &#34;wb&#34;) as otp_file:
            otp_file.write(pad.encode(&#34;utf-8&#34;))
        logging.info(f&#34;One-time-pad text written to: {pad_path}&#34;)

    if ciphertext_path:
        with open(ciphertext_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(ciphertext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Encrypted text written to: {ciphertext_path}&#34;)

    return ciphertext, pad

def decrypt(cipher_text:str, pad:str, text_path:str = False) -&gt; str:
    &#34;&#34;&#34;Decrypts ğŸ”“ text using provided pad.

    Parameters
    ----------
    cipher_text:(str)
        The text you would like to decrypt.

    pad:(str)
        The pad that corresponds with the ciphertext.

    text_path:(bool|str)
        If specified then it will be the path the decrypted
        text is written to.
        
    Returns
    ------
    str:
        The decrypted text

    Examples
    --------
    Encrypting some text from files found in the encrypt() example.
    ```
    from otp_emoji import decrypt

    pad = &#39;&#39;

    ciphertext = &#39;&#39;

    with open(&#39;pad.txt&#39;) as pad_file:
        pad = pad_file.read()

    with open(&#39;ciphertext.txt&#39;) as ciphertext_file:
        ciphertext = ciphertext_file.read()

    print( decrypt(ciphertext, pad) ) # Prints: &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;
    ```
    &#34;&#34;&#34;
    cipher_text = cipher_text.split(&#34;|&#34;) # Split ciphertext by pipes
    pad = pad.split(&#34;|&#34;) # Split pad by pipes

    print(&#34;ğŸ‘€ Decrypting text ğŸ‘€&#34;)

    plaintext = &#34;&#34;

    logging.debug(f&#34;cipher_text={cipher_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)

    for character in zip(cipher_text, pad): # Use pad to decrypt each character
        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)

        decrypted_value = &#34;&#34;
        logging.debug(f&#34;{character[0]} ^ {character[1]}&#34;)

        decrypted_value +=  chr(emoji_map[character[0]] ^ emoji_map[character[1]])
        plaintext += decrypted_value

    if text_path:
        with open(os.path.abspath(text_path), &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(plaintext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Decrypted text written to: {text_path}&#34;)

    return plaintext

def main() -&gt; None:
    &#34;&#34;&#34;otp_emoji script entrypoint; handles logic for the otp_emoji command&#34;&#34;&#34;
    if len(sys.argv) == 1: # If no arguments are provided
        print(usage)       # Print helptext
        exit()             # Exit program

    args = docopt(usage, version=&#34;otp_emoji V 1.3.0&#34;)

    # ================== Encrypt Argument Parsing ==================
    if args[&#34;encrypt&#34;]:        
        if os.path.isfile(args[&#34;&lt;text&gt;&#34;]):
            with open(args[&#34;&lt;text&gt;&#34;], encoding=&#34;utf-8&#34;) as text_file:
                args[&#34;&lt;text&gt;&#34;] = text_file.read()
        if args[&#34;--output&#34;]:
            if not os.path.isdir(args[&#34;--output&#34;]): # If no valid output directory specified
                args[&#34;--output&#34;] = os.curdir
        else:
            args[&#34;--output&#34;] = os.curdir

        ciphertext, pad = encrypt(args[&#34;&lt;text&gt;&#34;], args[&#34;--pad&#34;], pad_path=f&#34;{args[&#39;--output&#39;]}{os.sep}pad.txt&#34;, ciphertext_path=f&#34;{args[&#39;--output&#39;]}{os.sep}ciphertext.txt&#34;)

        if args[&#34;--stream&#34;]:
            print(f&#34;Ciphertext: {ciphertext}&#34;)
            print(f&#34;Pad: {pad}&#34;)
    
    # ================== Decrypt Argument Parsing ==================
    if args[&#34;decrypt&#34;]:
        with open(args[&#34;&lt;ciphertext&gt;&#34;], encoding=&#34;utf-8&#34;) as ciphertext_file:
            args[&#34;&lt;ciphertext&gt;&#34;] = ciphertext_file.read()
        
        with open(args[&#34;&lt;pad&gt;&#34;], encoding=&#34;utf-8&#34;) as pad_file:
            args[&#34;&lt;pad&gt;&#34;] = pad_file.read()

        if args[&#34;--output&#34;]:
            if not os.path.isdir(args[&#34;--output&#34;]): # If no valid output directory specified
                args[&#34;--output&#34;] = os.curdir
                print(f&#34;Provided output path was not valid using {os.curdir} instead&#34;)
            
            
        
        else:
            args[&#34;--output&#34;] = os.curdir

        plaintext = decrypt(args[&#34;&lt;ciphertext&gt;&#34;], args[&#34;&lt;pad&gt;&#34;], text_path=f&#34;{args[&#39;--output&#39;]}{os.sep}plaintext.txt&#34;)

        
        
        

        if args[&#34;--stream&#34;]:
            print(plaintext)

if __name__ == &#34;__main__&#34;:

    main() # Runs the otp_emoji command</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="otp_emoji.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>cipher_text, pad, text_path=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Decrypts ğŸ”“ text using provided pad.</p>
<h2 id="parameters">Parameters</h2>
<p>cipher_text:(str)
The text you would like to decrypt.</p>
<p>pad:(str)
The pad that corresponds with the ciphertext.</p>
<p>text_path:(bool|str)
If specified then it will be the path the decrypted
text is written to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code>:</dt>
<dd>The decrypted text</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Encrypting some text from files found in the encrypt() example.</p>
<pre><code>from otp_emoji import decrypt

pad = ''

ciphertext = ''

with open('pad.txt') as pad_file:
    pad = pad_file.read()

with open('ciphertext.txt') as ciphertext_file:
    ciphertext = ciphertext_file.read()

print( decrypt(ciphertext, pad) ) # Prints: 'Who controls the past controls the future. Who controls the present controls the past.'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt(cipher_text:str, pad:str, text_path:str = False) -&gt; str:
    &#34;&#34;&#34;Decrypts ğŸ”“ text using provided pad.

    Parameters
    ----------
    cipher_text:(str)
        The text you would like to decrypt.

    pad:(str)
        The pad that corresponds with the ciphertext.

    text_path:(bool|str)
        If specified then it will be the path the decrypted
        text is written to.
        
    Returns
    ------
    str:
        The decrypted text

    Examples
    --------
    Encrypting some text from files found in the encrypt() example.
    ```
    from otp_emoji import decrypt

    pad = &#39;&#39;

    ciphertext = &#39;&#39;

    with open(&#39;pad.txt&#39;) as pad_file:
        pad = pad_file.read()

    with open(&#39;ciphertext.txt&#39;) as ciphertext_file:
        ciphertext = ciphertext_file.read()

    print( decrypt(ciphertext, pad) ) # Prints: &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;
    ```
    &#34;&#34;&#34;
    cipher_text = cipher_text.split(&#34;|&#34;) # Split ciphertext by pipes
    pad = pad.split(&#34;|&#34;) # Split pad by pipes

    print(&#34;ğŸ‘€ Decrypting text ğŸ‘€&#34;)

    plaintext = &#34;&#34;

    logging.debug(f&#34;cipher_text={cipher_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)

    for character in zip(cipher_text, pad): # Use pad to decrypt each character
        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)

        decrypted_value = &#34;&#34;
        logging.debug(f&#34;{character[0]} ^ {character[1]}&#34;)

        decrypted_value +=  chr(emoji_map[character[0]] ^ emoji_map[character[1]])
        plaintext += decrypted_value

    if text_path:
        with open(os.path.abspath(text_path), &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(plaintext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Decrypted text written to: {text_path}&#34;)

    return plaintext</code></pre>
</details>
</dd>
<dt id="otp_emoji.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>input_text, pad=False, pad_path=False, ciphertext_path=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Encrypts ğŸ”’ text using provided pad, or generates one of the same length.</p>
<h2 id="parameters">Parameters</h2>
<p>input_text:(str)
The text you would like to encrypt.</p>
<p>pad:(bool|str)
If pad is specified it will be used to encrypt
if left False it will be generated for you.</p>
<p>pad_path:(bool|str)
If specified then it will be the path the pad is
written to.</p>
<p>ciphertext_path:(bool|str)
If specified then it will be the path the ciphertext
is written to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code>[<code>str</code>,<code>str</code>]:</dt>
<dd>The ciphertext, and the onetime pad</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Encrypting a 1984 (George Orwell) quote and saving
the resulting ciphertext and path to files.</p>
<pre><code>from otp_emoji import encrypt

text = 'Who controls the past controls the future. Who controls the present controls the past.'

# Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
ciphertext, pad = encrypt(text, pad_path='./pad.txt', ciphertext_path='./ciphertext.txt')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt(input_text:str, pad:bool=False, pad_path:str = False, ciphertext_path:str = False) -&gt; tuple:
    &#34;&#34;&#34;Encrypts ğŸ”’ text using provided pad, or generates one of the same length.

    Parameters
    ----------
    input_text:(str)
        The text you would like to encrypt.

    pad:(bool|str)
        If pad is specified it will be used to encrypt 
        if left False it will be generated for you.

    pad_path:(bool|str)
        If specified then it will be the path the pad is
        written to.

    ciphertext_path:(bool|str)
        If specified then it will be the path the ciphertext
        is written to.
        
    Returns
    ------
    tuple[str,str]:
        The ciphertext, and the onetime pad

    Examples
    --------
    Encrypting a 1984 (George Orwell) quote and saving
    the resulting ciphertext and path to files.
    ```
    from otp_emoji import encrypt

    text = &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;

    # Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
    ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)
    ```
    &#34;&#34;&#34;
    print(&#34;ğŸ”’ Encrypting Text ğŸ”’&#34;)

    logging.debug(f&#34;input_text = {input_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)
    logging.debug(f&#34;pad_path={pad_path}&#34;)
    logging.debug(f&#34;ciphertext_path={ciphertext_path}&#34;)


    ciphertext = &#34;&#34;
    if not pad:
        pad = &#34;&#34;
        for count, character in enumerate(generate_otp(len(input_text))):
            logging.debug(character)
            pad += character
            shifted_value = &#34;&#34;
            character = character[0:-1] # remove | delimiter from pad character

            logging.debug(f&#34;{input_text[count]} ^ {character}({emoji_map[character]})&#34;)
            shifted_value += cipher_chars[(ord(input_text[count]) ^ emoji_map[character])]

            ciphertext += (shifted_value) + &#34;|&#34; # Delimit ciphertext by pipes and append

        logging.debug(f&#34;pad={pad}&#34;)
    
    else: # If custom pad is provided
        pad = deepcopy(pad)
        pad = pad.split(&#34;|&#34;)
        for character in zip(input_text, pad):
            print(f&#34;Character= {character[0]} {character[1]}&#34;)
            shifted_value = &#34;&#34;
            logging.debug(f&#34;{input_text[count]} ^ {character}({emoji_map[character]})&#34;)
            shifted_value += cipher_chars[(ord(input_text[count]) ^ emoji_map[character])]

            ciphertext += (shifted_value) + &#34;|&#34; # Delimit ciphertext by pipes and append

    ciphertext = ciphertext[0:-1]
    if pad_path:
        with open(pad_path, &#34;wb&#34;) as otp_file:
            otp_file.write(pad.encode(&#34;utf-8&#34;))
        logging.info(f&#34;One-time-pad text written to: {pad_path}&#34;)

    if ciphertext_path:
        with open(ciphertext_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(ciphertext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Encrypted text written to: {ciphertext_path}&#34;)

    return ciphertext, pad</code></pre>
</details>
</dd>
<dt id="otp_emoji.generate_otp"><code class="name flex">
<span>def <span class="ident">generate_otp</span></span>(<span>length)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a one time pad of emojis based on input length.</p>
<h2 id="parameters">Parameters</h2>
<p>length:(int)
The amount of random emoji's to generate.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code>:</dt>
<dd>The next character in the one time pad</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Generating a 10 character otp</p>
<pre><code>from otp_emoji import generate_otp

otp = generate_otp(10)

for character in otp:   # Iterate through resulting generator
    print(character)    # Prints: ğŸ™ğŸ§—ğŸ§›ğŸ‘¨â€ğŸ¤ğŸ©ğŸ¥¯ğŸ§›ğŸ™„ğŸºğŸ§
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_otp(length:int) -&gt; Generator:
    &#34;&#34;&#34;Generates a one time pad of emojis based on input length.

    Parameters
    ----------
    length:(int)
        The amount of random emoji&#39;s to generate.
        
    Yields
    ------
    str:
        The next character in the one time pad

    Examples
    --------
    Generating a 10 character otp
    ```
    from otp_emoji import generate_otp

    otp = generate_otp(10)

    for character in otp:   # Iterate through resulting generator
        print(character)    # Prints: ğŸ™ğŸ§—ğŸ§›ğŸ‘¨â€ğŸ¤ğŸ©ğŸ¥¯ğŸ§›ğŸ™„ğŸºğŸ§
    ```
    &#34;&#34;&#34;
    for digit in range(length):
        hex_value = int(token_hex(1), 16)
        yield cipher_chars[hex_value] + &#34;|&#34;</code></pre>
</details>
</dd>
<dt id="otp_emoji.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>otp_emoji script entrypoint; handles logic for the otp_emoji command</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main() -&gt; None:
    &#34;&#34;&#34;otp_emoji script entrypoint; handles logic for the otp_emoji command&#34;&#34;&#34;
    if len(sys.argv) == 1: # If no arguments are provided
        print(usage)       # Print helptext
        exit()             # Exit program

    args = docopt(usage, version=&#34;otp_emoji V 1.3.0&#34;)

    # ================== Encrypt Argument Parsing ==================
    if args[&#34;encrypt&#34;]:        
        if os.path.isfile(args[&#34;&lt;text&gt;&#34;]):
            with open(args[&#34;&lt;text&gt;&#34;], encoding=&#34;utf-8&#34;) as text_file:
                args[&#34;&lt;text&gt;&#34;] = text_file.read()
        if args[&#34;--output&#34;]:
            if not os.path.isdir(args[&#34;--output&#34;]): # If no valid output directory specified
                args[&#34;--output&#34;] = os.curdir
        else:
            args[&#34;--output&#34;] = os.curdir

        ciphertext, pad = encrypt(args[&#34;&lt;text&gt;&#34;], args[&#34;--pad&#34;], pad_path=f&#34;{args[&#39;--output&#39;]}{os.sep}pad.txt&#34;, ciphertext_path=f&#34;{args[&#39;--output&#39;]}{os.sep}ciphertext.txt&#34;)

        if args[&#34;--stream&#34;]:
            print(f&#34;Ciphertext: {ciphertext}&#34;)
            print(f&#34;Pad: {pad}&#34;)
    
    # ================== Decrypt Argument Parsing ==================
    if args[&#34;decrypt&#34;]:
        with open(args[&#34;&lt;ciphertext&gt;&#34;], encoding=&#34;utf-8&#34;) as ciphertext_file:
            args[&#34;&lt;ciphertext&gt;&#34;] = ciphertext_file.read()
        
        with open(args[&#34;&lt;pad&gt;&#34;], encoding=&#34;utf-8&#34;) as pad_file:
            args[&#34;&lt;pad&gt;&#34;] = pad_file.read()

        if args[&#34;--output&#34;]:
            if not os.path.isdir(args[&#34;--output&#34;]): # If no valid output directory specified
                args[&#34;--output&#34;] = os.curdir
                print(f&#34;Provided output path was not valid using {os.curdir} instead&#34;)
            
            
        
        else:
            args[&#34;--output&#34;] = os.curdir

        plaintext = decrypt(args[&#34;&lt;ciphertext&gt;&#34;], args[&#34;&lt;pad&gt;&#34;], text_path=f&#34;{args[&#39;--output&#39;]}{os.sep}plaintext.txt&#34;)

        
        
        

        if args[&#34;--stream&#34;]:
            print(plaintext)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#script-usage">ğŸ–¥ï¸Script Usage</a></li>
<li><a href="#variables">ğŸ“¦Variables</a></li>
<li><a href="#notes">ğŸ“Notes</a></li>
<li><a href="#references">ğŸ‘©â€ğŸ«References</a></li>
<li><a href="#examples">ğŸ¤·Examples</a></li>
<li><a href="#todo">TODO</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="otp_emoji.decrypt" href="#otp_emoji.decrypt">decrypt</a></code></li>
<li><code><a title="otp_emoji.encrypt" href="#otp_emoji.encrypt">encrypt</a></code></li>
<li><code><a title="otp_emoji.generate_otp" href="#otp_emoji.generate_otp">generate_otp</a></code></li>
<li><code><a title="otp_emoji.main" href="#otp_emoji.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>